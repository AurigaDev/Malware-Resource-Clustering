def write_header(file, depth):
    ''' Write OpenXES disclaimer, and encoding information
        @param file - file descriptor
        @param depth - number of tabs to indicate scope
    '''
    file.write("\t"*depth+"<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n")
    file.write("\t"*depth+"<!-- This file has been generated with the OpenXES library. It conforms -->\n")
    file.write("\t"*depth+"<!-- to the XML serialization of the XES standard for log storage and -->\n")
    file.write("\t"*depth+"<!-- management. -->\n")
    file.write("\t"*depth+"<!-- XES standard version: 1.0 -->\n")
    file.write("\t"*depth+"<!-- OpenXES library version: 1.0RC7 -->\n")
    file.write("\t"*depth+"<!-- OpenXES is available from http://www.openxes.org/ -->\n")

def write_log_descriptor(file,file_name,depth):
    ''' Write Log descriptor and specify  name of log
        @param file - file descriptor
        @param file_name - specifies name of log
        @param depth - number of tabs to indicate scope
    '''
    file.write("\t"*depth+"<log xes.version=\"1.0\" xes.features=\"nested-attributes\" openxes.version=\"1.0RC7\">\n")
    depth+=1
    file.write("\t"*depth+"<extension name=\"Lifecycle\" prefix=\"lifecycle\" uri=\"http://www.xes-standard.org/lifecycle.xesext\"/>\n")
    file.write("\t"*depth+"<extension name=\"Time\" prefix=\"time\" uri=\"http://www.xes-standard.org/time.xesext\"/>\n")
    file.write("\t"*depth+"<extension name=\"Concept\" prefix=\"concept\" uri=\"http://www.xes-standard.org/concept.xesext\"/>\n")
    file.write("\t"*depth+"<classifier name=\"Event Name\" keys=\"concept:name\"/>\n")
    file.write("\t"*depth+"<classifier name=\"(Event Name AND Lifecycle transition)\" keys=\"concept:name lifecycle:transition\"/>\n")
    file.write("\t"*depth+"<string key=\"concept:name\" value=\""+file_name+"\"/>\n")

def write_serial_events(file, log_list, depth):
    ''' Write each trace, write each event in trace, and write value of event
        @param file - file descriptor
        @param log_list - a list of traces that are space delimited
        @param depth - number of tabs to indicate scope
    '''
    trace_count = 0
    depth+=1
    # for each entry in log_list
    for trace in log_list:
        # Open Context
        file.write("\t"*depth+"<trace>\n")
        depth+=1
        trace_count+=1
        file.write("\t"*depth+"<string key=\"concept:name\" value=\""+str(trace_count)+"\"/>\n")
        for event in trace.split(' '):
            file.write("\t"*depth+"<event>\n")
            depth+=1
            file.write("\t"*depth+"<string key=\"concept:name\" value=\""+event+"\"/>\n")
            depth-=1
            file.write("\t"*depth+"</event>\n")
        depth-=1
        file.write("\t"*depth+"</trace>\n")
    depth-=1
    file.write("\t"*depth+"</log>")

def write_csv_events(file, log_list, depth):
    ''' Request which is primary key, and which is what kind of data.
        This requires more interaction
        @param file - file descriptor
        @param log_list - a list of traces that are space delimited
        @param depth - number of tabs to indicate scope
    '''
    trace_count = 0
    depth+=1
    # for each entry in log_list
    for trace in log_list:
        # Open Context
        file.write("\t"*depth+"<trace>\n")
        depth+=1
        trace_count+=1
        file.write("\t"*depth+"<string key=\"concept:name\" value=\""+str(trace_count)+"\"/>\n")
        for event in trace.split(' '):
            file.write("\t"*depth+"<event>\n")
            depth+=1
            # TODO:: requires user interaction to specify fields of relevance, and key
            depth-=1
            file.write("\t"*depth+"</event>\n")
        depth-=1
        file.write("\t"*depth+"</trace>\n")
    depth-=1
    file.write("\t"*depth+"</log>")
    
if __name__ == '__main__':
    file_name = "sample.xes"
    f = open(file_name,"w")
    depth = 0
    # Write header
    write_header(f, depth)
    
    # Write Log Descriptor
    write_log_descriptor(f, file_name, depth)
    
    temp = ["a b c d","a c b d","a e d"]

    write_serial_events(f, temp, depth)
    #write_csv_events(f, temp, depth)
    f.close